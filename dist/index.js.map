{"version":3,"sources":["../src/index.ts","../src/providers/verifiableLogProvider.ts","../src/adapters/sqliteVerifiableDAO.ts","../src/types/logTypes.ts","../src/providers/dreriveProvider.ts"],"sourcesContent":["import { type IAgentRuntime, type Plugin, Service, ServiceType } from \"@elizaos/core\";\nimport { VerifiableLogProvider } from \"./providers/verifiableLogProvider.ts\";\nimport { SQLite3VerifiableDAO } from \"./adapters/sqliteVerifiableDAO.ts\";\nimport {\n    PageQuery,\n    VerifiableAgent,\n    type VerifiableDAO,\n    VerifiableLog,\n    VerifiableLogQuery,\n} from \"./types/logTypes.ts\";\n\nexport { PageQuery, VerifiableAgent, VerifiableLog, VerifiableLogQuery };\nexport { DeriveProvider } from \"./providers/dreriveProvider.ts\"\n\nexport class VerifiableLogService extends Service {\n    getInstance(): VerifiableLogService {\n        return this;\n    }\n\n    static get serviceType(): ServiceType {\n        return ServiceType.VERIFIABLE_LOGGING;\n    }\n\n    private verifiableLogProvider: VerifiableLogProvider;\n    private verifiableDAO: VerifiableDAO;\n\n    private teeMode: string;\n    private vlogOpen = false;\n\n    // Add abstract initialize method that must be implemented by derived classes\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        if (runtime.databaseAdapter.db === null) {\n            throw new Error(\"Database adapter is not initialized.\");\n        }\n        if (runtime.getSetting(\"TEE_MODE\") === null) {\n            throw new Error(\"TEE_MODE is not set.\");\n        }\n        if (runtime.getSetting(\"WALLET_SECRET_SALT\") === null) {\n            throw new Error(\"WALLET_SECRET_SALT is not set.\");\n        }\n        this.teeMode = runtime.getSetting(\"TEE_MODE\");\n        const value = runtime.getSetting(\"VLOG\");\n        const truthyValues = [\"yes\", \"true\", \"YES\", \"TRUE\", \"Yes\", \"True\", \"1\"];\n        this.vlogOpen = truthyValues.includes(value.toLowerCase());\n        this.verifiableDAO = new SQLite3VerifiableDAO(\n            runtime.databaseAdapter.db\n        );\n        this.verifiableLogProvider = new VerifiableLogProvider(\n            this.verifiableDAO,\n            this.teeMode\n        );\n        const isOK = await this.verifiableLogProvider.registerAgent(\n            { agentId: runtime?.agentId, agentName: runtime?.character?.name },\n            this.teeMode\n        );\n        if (!isOK) {\n            throw new Error(`Failed to register agent.${runtime.agentId}`);\n        }\n        return;\n    }\n\n    async log(params: {\n        agentId: string;\n        roomId: string;\n        userId: string;\n        type: string;\n        content: string;\n    }): Promise<boolean> {\n        if (this.vlogOpen) {\n            return this.verifiableLogProvider.log(params, this.teeMode);\n        }\n        return false;\n    }\n\n    async generateAttestation(params: {\n        agentId: string;\n        publicKey: string;\n    }): Promise<string> {\n        if (this.vlogOpen) {\n            return this.verifiableLogProvider.generateAttestation(\n                params,\n            );\n        }\n        return \"\";\n    }\n\n    async listAgent(): Promise<VerifiableAgent[]> {\n        return this.verifiableDAO.listAgent();\n    }\n\n    async pageQueryLogs(\n        query: VerifiableLogQuery,\n        page: number,\n        pageSize: number\n    ): Promise<PageQuery<VerifiableLog[]>> {\n        return this.verifiableDAO.pageQueryLogs(query, page, pageSize);\n    }\n}\n\nexport const verifiableLogPlugin: Plugin = {\n    name: \"TeeVerifiableLog\",\n    description:\n        \"While Eliza operates within the TEE, it uses a derived key pair to sign its actions, ensuring that these actions are definitively executed by Eliza. Third-party users can remotely verify Eliza's public key to validate these actions\",\n    actions: [],\n    evaluators: [],\n    providers: [],\n    services: [new VerifiableLogService()],\n};\n","import { elizaLogger } from \"@elizaos/core\";\nimport type {\n    IVerifiableLogProvider,\n    VerifiableAgent,\n    VerifiableDAO,\n    VerifiableLog,\n} from \"../types/logTypes.ts\";\nimport {\n    DeriveKeyProvider,\n    RemoteAttestationProvider,\n    type RemoteAttestationQuote,\n} from \"@elizaos/plugin-tee\";\n\nexport class VerifiableLogProvider implements IVerifiableLogProvider {\n    private dao: VerifiableDAO;\n    private keyPath = \"/keys/verifiable_key\";\n    private remoteAttestationProvider: RemoteAttestationProvider;\n    private provider: DeriveKeyProvider;\n\n    constructor(dao: VerifiableDAO, teeMode: string) {\n        this.dao = dao;\n        this.remoteAttestationProvider = new RemoteAttestationProvider(teeMode);\n        this.provider = new DeriveKeyProvider(teeMode);\n    }\n\n    async log(\n        params: {\n            agentId: string;\n            roomId: string;\n            userId: string;\n            type: string;\n            content: string;\n        },\n        subject: string\n    ): Promise<boolean> {\n        let singed = \"\";\n\n        try {\n            const evmKeypair = await this.provider.deriveEcdsaKeypair(\n                this.keyPath,\n                subject,\n                params.agentId\n            );\n            const signature = await evmKeypair.keypair.signMessage({\n                message: params.content,\n            });\n            singed = signature.toString();\n\n            // evmKeypair can now be used for Ethereum operations\n        } catch (error) {\n            elizaLogger.error(\"EVM key derivation failed:\", error)\n            return false;\n        }\n        return this.dao.addLog(<VerifiableLog>{\n            agent_id: params.agentId,\n            room_id: params.roomId,\n            user_id: params.userId,\n            type: params.type,\n            content: params.content,\n            signature: singed,\n        });\n    }\n\n    async registerAgent(\n        params: {\n            agentId: string;\n            agentName: string;\n        },\n        subject: string\n    ): Promise<boolean> {\n        if (params.agentId === undefined) {\n            throw new Error(\"agentId is required\");\n        }\n\n        const agent = await this.dao.getAgent(params.agentId);\n        if (agent !== null) {\n            return true;\n        }\n        const evmKeypair = await this.provider.deriveEcdsaKeypair(\n            this.keyPath,\n            subject,\n            params.agentId\n        );\n\n        const publicKey = evmKeypair.keypair.publicKey;\n\n        return this.dao.addAgent(<VerifiableAgent>{\n            agent_id: params.agentId,\n            agent_name: params.agentName,\n            agent_keypair_path: this.keyPath,\n            agent_keypair_vlog_pk: publicKey,\n        });\n    }\n\n    async generateAttestation(\n        params: {\n            agentId: string;\n            publicKey: string;\n        }\n    ): Promise<string> {\n        if (params.agentId === undefined || params.publicKey === undefined) {\n            throw new Error(\"agentId and publicKey are required\");\n        }\n        try {\n            // Generate 32-byte report data (reportData) containing the hash value of the public key.\n            const reportData = JSON.stringify(params);\n            // Call the remote attestation interface.\n            const quote: RemoteAttestationQuote = await this.remoteAttestationProvider.generateAttestation(reportData);\n            return JSON.stringify(quote);\n        } catch (error) {\n            elizaLogger.error(\"Failed to generate attestation quote:\", error);\n            throw error;\n        }\n    }\n}\n","import type { Database } from \"better-sqlite3\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n    type VerifiableLog,\n    type VerifiableAgent,\n    VerifiableDAO,\n    type VerifiableLogQuery,\n    type PageQuery,\n} from \"../types/logTypes.ts\";\n\nexport class SQLite3VerifiableDAO extends VerifiableDAO<Database> {\n    constructor(db: Database) {\n        super();\n        this.db = db;\n        // load(db);\n        // check if the tables exist, if not create them\n        const tables = db\n            .prepare(\n                \"SELECT name FROM sqlite_master WHERE type='table' AND name IN ('verifiable-logs', 'verifiable-agents');\"\n            )\n            .all();\n        if (tables.length !== 2) {\n            this.initializeSchema();\n        }\n    }\n\n    async initializeSchema(): Promise<void> {\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS \"tee_verifiable_logs\"\n            (\n                \"id\"         TEXT PRIMARY KEY,\n                \"created_at\" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                \"agent_id\"   TEXT NOT NULL,\n                \"room_id\"    TEXT NOT NULL,\n                \"user_id\"    TEXT,\n                \"type\"       TEXT,\n                \"content\"    TEXT NOT NULL,\n                \"signature\"  TEXT NOT NULL\n            );\n        `);\n\n        this.db.exec(`\n            CREATE TABLE IF NOT EXISTS \"tee_verifiable_agents\"\n            (\n                \"id\"                    TEXT PRIMARY KEY,\n                \"created_at\"            TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                \"agent_id\"              TEXT NOT NULL,\n                \"agent_name\"            TEXT,\n                \"agent_keypair_path\"    TEXT NOT NULL,\n                \"agent_keypair_vlog_pk\" TEXT NOT NULL,\n                UNIQUE (\"agent_id\")\n            );\n        `);\n    }\n\n    async addLog(log: VerifiableLog): Promise<boolean> {\n        const sql = `\n            INSERT INTO \"tee_verifiable_logs\" (\"id\", \"created_at\", \"agent_id\", \"room_id\", \"user_id\", \"type\", \"content\",\n                                           \"signature\")\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?);\n        `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    log.id || uuidv4(),\n                    log.created_at || new Date().getTime(),\n                    log.agent_id,\n                    log.room_id,\n                    log.user_id,\n                    log.type,\n                    log.content,\n                    log.signature\n                );\n            return true;\n        } catch (error) {\n            console.error(\"SQLite3 Error adding log:\", error);\n            return false;\n        }\n    }\n\n    async pageQueryLogs(\n        query: VerifiableLogQuery,\n        page: number,\n        pageSize: number\n    ): Promise<PageQuery<VerifiableLog[]>> {\n        const conditions: string[] = [];\n        const params: (string | number)[] = [];\n\n        if (query.idEq) {\n            conditions.push('id = ?');\n            params.push(query.idEq);\n        }\n        if (query.agentIdEq) {\n            conditions.push('agent_id = ?');\n            params.push(query.agentIdEq);\n        }\n        if (query.roomIdEq) {\n            conditions.push('room_id = ?');\n            params.push(query.roomIdEq);\n        }\n        if (query.userIdEq) {\n            conditions.push('user_id = ?');\n            params.push(query.userIdEq);\n        }\n        if (query.typeEq) {\n            conditions.push('type = ?');\n            params.push(query.typeEq);\n        }\n        if (query.contLike) {\n            conditions.push('content LIKE ?');\n            params.push(`%${query.contLike}%`);\n        }\n        if (query.signatureEq) {\n            conditions.push('signature = ?');\n            params.push(query.signatureEq);\n        }\n\n        const whereClause =\n            conditions.length > 0 ? `WHERE ${conditions.join(\" AND \")}` : \"\";\n\n        let currentPage = page;  // Create a new variable instead of reassigning parameter\n        if (currentPage < 1) {\n            currentPage = 1;\n        }\n        const offset = (currentPage - 1) * pageSize;\n        const limit = pageSize;\n\n\n        try {\n            const totalQuery = `SELECT COUNT(*) AS total\n                                FROM tee_verifiable_logs ${whereClause}`;\n            const stmt = this.db.prepare(totalQuery);\n            const totalResult = stmt.get(params) as { total: number };\n            const total = totalResult.total;\n\n            const dataQuery = `\n                SELECT *\n                FROM tee_verifiable_logs ${whereClause}\n                ORDER BY created_at DESC\n                LIMIT ? OFFSET ?\n            `;\n            const dataResult = this.db\n                .prepare(dataQuery)\n                .all(...params, limit, offset);\n\n            return {\n                page: page,\n                pageSize: pageSize,\n                total: total,\n                data: dataResult,\n            } as PageQuery<VerifiableLog[]>;\n        } catch (error) {\n            console.error(\"Error querying tee_verifiable_logs:\", error);\n            throw error;\n        }\n    }\n\n    async addAgent(agent: VerifiableAgent): Promise<boolean> {\n        const sql = `\n            INSERT INTO \"tee_verifiable_agents\" (\"id\", \"created_at\", \"agent_id\",\"agent_name\",\"agent_keypair_path\", \"agent_keypair_vlog_pk\")\n            VALUES (?, ?, ?, ?, ?,?);\n        `;\n        try {\n            this.db\n                .prepare(sql)\n                .run(\n                    agent.id || uuidv4(),\n                    agent.created_at || new Date().getTime(),\n                    agent.agent_id,\n                    agent.agent_name||\"agent bot\",\n                    agent.agent_keypair_path,\n                    agent.agent_keypair_vlog_pk\n                );\n            return true;\n        } catch (error) {\n            console.error(\"SQLite3 Error adding agent:\", error);\n            return false;\n        }\n    }\n\n    async getAgent(agentId: string): Promise<VerifiableAgent> {\n        const sql = `SELECT *\n                     FROM \"tee_verifiable_agents\"\n                     WHERE agent_id = ?`;\n        try {\n            const agent = this.db.prepare(sql).get(agentId);\n            if (agent) {\n                return agent as VerifiableAgent;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"SQLite3 Error getting agent:\", error);\n            throw error;\n        }\n    }\n\n    async listAgent(): Promise<VerifiableAgent[]> {\n        const sql = `SELECT *\n                     FROM \"tee_verifiable_agents\"`;\n        try {\n            const agents = this.db.prepare(sql).all();\n            return agents as VerifiableAgent[];\n        } catch (error) {\n            console.error(\"SQLite3 Error listing agent:\", error);\n            throw error;\n        }\n    }\n}\n","export interface VerifiableLog {\n    id: string; // Primary Key UUID\n    created_at?: Date; // Default value: CURRENT_TIMESTAMP\n    agent_id: string; // Not null\n    room_id: string; // Not null\n    user_id: string; // Not null\n    type: string; // Not null\n    content: string; // Not null\n    signature: string; // Not null\n}\nexport interface VerifiableLogQuery {\n    idEq: string;\n    agentIdEq: string;\n    roomIdEq: string;\n    userIdEq: string;\n    typeEq: string;\n    contLike: string;\n    signatureEq: string;\n}\n\nexport interface VerifiableAgent {\n    id: string; // Primary Key\n    created_at?: Date; // Default value: CURRENT_TIMESTAMP\n    agent_id: string; // Not null\n    agent_name: string; // Not null\n    agent_keypair_path: string; // Not null\n    agent_keypair_vlog_pk: string; // Not null\n}\n\nexport interface PageQuery<Result = unknown> {\n    page: number;\n    pageSize: number;\n    total?: number;\n    data?: Result;\n}\n\nexport abstract class VerifiableDAO<DB = unknown> {\n    protected constructor() {}\n\n    /**\n     * The database instance.\n     */\n    db: DB;\n\n    /**\n     * Optional initialization method for the database adapter.\n     * @returns A Promise that resolves when initialization is complete.\n     */\n    abstract initializeSchema(): Promise<void>;\n\n    /**\n     * insert log to table\n     * @param log\n     */\n    abstract addLog(log: VerifiableLog): Promise<boolean>;\n\n    /**\n     * Performs a paginated query for VerifiableLogs based on the given criteria.\n     *\n     * @param agentQuery - The query parameters to filter the logs.\n     * @param page - The page number to retrieve (1-based).\n     * @param pageSize - The number of items per page.\n     * @returns A Promise that resolves to a PageQuery object containing an array of VerifiableLogs.\n     */\n    abstract pageQueryLogs(\n        agentQuery: VerifiableLogQuery,\n        page: number,\n        pageSize: number\n    ): Promise<PageQuery<VerifiableLog[]>>;\n\n    /**\n     * insert Verifiable Agent info to table\n     * @param agent\n     */\n    abstract addAgent(agent: VerifiableAgent): Promise<boolean>;\n\n    /**\n     * Retrieves a VerifiableAgent by its agentId.\n     *\n     * @param agentId - The unique identifier of the agent to retrieve.\n     * @returns A Promise that resolves to a VerifiableAgent object.\n     */\n    abstract getAgent(agentId: string): Promise<VerifiableAgent>;\n\n    /**\n     * Retrieves a list of all VerifiableAgents.\n     *\n     * @returns A Promise that resolves to an array of VerifiableAgent objects.\n     */\n    abstract listAgent(): Promise<VerifiableAgent[]>;\n}\n\nexport interface IVerifiableLogProvider {\n    /**\n     * Logs a message with the given parameters.\n     *\n     * @param params - The parameters for the log message.\n     * @param endpoint - Tee endpoint.\n     * @returns A Promise that resolves to a boolean indicating whether the log was successful.\n     */\n    log(\n        params: {\n            agentId: string;\n            roomId: string;\n            userId: string;\n            type: string;\n            content: string;\n        },\n        endpoint: string\n    ): Promise<boolean>;\n\n    /**\n     * Registers a new agent with the given parameters.\n     *\n     * @param params - The parameters for the agent registration.\n     * @param endpoint - Tee endpoint.\n     * @returns A Promise that resolves to a boolean indicating whether the registration was successful.\n     */\n    registerAgent(\n        params: {\n            agentId: string;\n        },\n        endpoint: string\n    ): Promise<boolean>;\n}\n","import { DeriveKeyProvider } from \"@elizaos/plugin-tee\";\nimport * as crypto from \"node:crypto\";  // Added node: protocol\n\nexport class DeriveProvider {\n    private provider: DeriveKeyProvider;\n\n    constructor(teeModel: string) {\n        this.provider = new DeriveKeyProvider(teeModel);\n    }\n\n    async deriveKeyPair(params: {\n        agentId: string;\n        bizModel: string;\n    }): Promise<Buffer> {\n        const keyPath = `/${params.agentId}/tee/keypair/${params.bizModel}`;\n        const seed = await this.provider.rawDeriveKey(keyPath, params.agentId);\n        const privateKey = crypto.createPrivateKey({\n            key: seed.key,\n            format: \"pem\",\n        });\n        const privateKeyDer = privateKey.export({\n            format: \"der\",\n            type: \"pkcs8\",\n        });\n        return crypto.createHash(\"sha256\").update(privateKeyDer).digest();\n    }\n\n    async encryptAgentData(\n        params: {\n            agentId: string;\n            bizModel: string;\n        },\n        plainText: string\n    ): Promise<{\n        success: boolean;\n        errorMsg: string;\n        ivHex: string;\n        encryptedData: string;\n    }> {\n        try {\n            const rawKey = await this.deriveKeyPair(params);\n            const { ivHex, encrypted } = this.encrypt(plainText, rawKey);\n\n            return {\n                success: true,\n                errorMsg: \"\",\n                ivHex: ivHex,\n                encryptedData: encrypted,\n            };\n        } catch (error) {\n            return {\n                success: true,\n                errorMsg: `encryptAgentData failed: ${error}`,  // Changed to template literal\n                ivHex: \"\",\n                encryptedData: \"\",\n            };\n        }\n    }\n\n    async decryptAgentData(\n        params: {\n            agentId: string;\n            bizModel: string;\n        },\n        ivHex: string,\n        encryptedData: string\n    ): Promise<{\n        success: boolean;\n        errorMsg: string;\n        plainText: string;\n    }> {\n        try {\n            const rawKey = await this.deriveKeyPair(params);\n            const plainText = this.decrypt(encryptedData, ivHex, rawKey);\n            return {\n                success: true,\n                errorMsg: \"\",\n                plainText: plainText,\n            };\n        } catch (error) {\n            return {\n                success: false,\n                errorMsg: `decryptAgentData failed: ${error}`,  // Changed to template literal\n                plainText: \"\",\n            };\n        }\n    }\n\n    private encrypt(\n        text: string,\n        key: Buffer\n    ): { ivHex: string; encrypted: string } {\n        // generate a random initialization vector iv\n        const iv = crypto.randomBytes(16);\n\n        // create cipher object\n        const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n\n        let encrypted = cipher.update(text, \"utf8\", \"hex\");\n        encrypted += cipher.final(\"hex\");\n\n        //Return IV and encrypted data (IV needs to be used during decryption)\n        return { ivHex: iv.toString(\"hex\"), encrypted: encrypted };\n    }\n\n    private decrypt(encryptedData: string, ivHex: string, key: Buffer): string {\n        const decipher = crypto.createDecipheriv(\n            \"aes-256-cbc\",\n            key,\n            Buffer.from(ivHex, \"hex\")\n        );\n        let decrypted = decipher.update(encryptedData, \"hex\", \"utf8\");\n        decrypted += decipher.final(\"utf8\");\n        return decrypted;\n    }\n}\n"],"mappings":"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","names":["DeriveKeyProvider"]}